# Erm For Dummies, by Qurqirish Dragon
이제 저번 5줄짜리 스크립트에서 확장을 해보자. 

북서 끝에 매 10번째 마다 방문한 영웅에게 마법적으로 강력하게 약하게 그리고 보통으로 반복하도록 해보자. 10번째 방문시 모든 영웅에게 전투에서 두배의 SP를 받도록 하고, 20번째 방문에는 모두 SP가 1이되게, 그다음 30번째에는 원래대로 그리고 이일이 반복적으로 일어나도록 해보자. 

먼저, !!VR과 !!IF사이에 한줄을 넣어보자.  (10xn)번째 방문자 임을 확인하는 코드를 넣으면 되겠다. 잠시 필요한 변수가 필요하다 이럴 때는 y변수가 ERM에 준비되어 있다. y변수는 스크립트간 보존되지 않는다. 계속해서 보존될 값이 아니라면 사용하도록 하자. 
`!!VRy1:Sv1%10; [ 10번씩 몇번 방문했는지? ] `

이 명령은 한 문장을 위해 두개의 연산자를 사용했다. ERM에서 모든 수학연산은 왼쪽에서 오른쪽으로 이루어진다. 여러 연산을 수행하고 싶으면 여러줄로 나누는 것이 쉬울것이다.    y1에는 v1%10연산 결과를 대입한다로 해석하면 된다. 
만약 y1이 0이라면 매 10번째 방문에 해당할 것이다. 

원래는 10번째 방문마다 아무일도 일어나지 않으므로, 약간의 변화를 주어 메시지를 출력해보자. 
`!!IF%y1<>0:M^당신은 북서쪽 끝면에 도달한 %V1번째 방문자입니다.!^; `

콜론 이전에 &y1<>0이라는 조건문이 추가되었다. 해당 조건문은 y1값이 0이 아닐 때를 말한다.  조건문이 참이라면 이어지는 코드가 실행되며, 거짓이라면 아무일도 일어나지 않는다. 

서북 끝단에 닿아도 카운터는 증가하지만 무언가가 일어나지는 않는 경우가 생긴다.

이제 v1이 10의 배수일 때마다 메시지 창이 바뀌어지도록 해보자. 약간의 변화로 이것을 할 수 있다. 새로운 y변수를 도입해서 이것을 확인해보자. 
`!!VRy2:Sv1:10%3; [마법 변화 타입 찾기] `

v1값을 10으로 나눈 몫을 3으로 나눈 후 나머지를 찿는 계산이다. 이 값은 10의 자리수가 1,4,7이 반복될 때, 2,5,8이 반복될 때를 구분하게 된다. 

우리는 이제 타입변화에 따라  3개의 IF명령어를 필요로 한다. 
- "당신은 n번째 방문자입니다. [공통], 당신은 마력이 강화됌을 알게 됩니다. "
- "[공통], 세계의 마력이 약화됌을 느낍니다. ", 
- "[공통], 세계의 마력이 원래대로 돌아옴을 느낍니다."   
대부분의 메시지가 비슷합니다. 일일이 타이핑할 필요없이 조금만 추가하면 여러 가능성이 더해집니다. 

이제 새로운 z변수를 사용해봅시다. z변수는 문자열을 저장할 수 있는 유일한 변수 입니다. v변수 처럼 휘발하지 않는 값입니다. 그렇지만 몇개의 변수는 y변수처럼 순간을 위해 사용됍니다. ERM도움말에는 z-1에서 z-10이 그렇게 사용된다고 합니다. 이제 z-1변수에 약간의 문자열 변화를 넣도록 합시다. 
```
!!VRz-1&y2=0:S^원래대로 돌아옴을^; [ 30,60,90번째 ] 
!!VRz-1&y2=1:S^강회됌을^; [ 10,40,70번째 ] 
!!VRz-1&y2=2:S^약화됌을^; [ 20,50,80번째 ] 
```

이제 당신은 이 문장을 잘 이해할 수 있습니다. 이제 IF:M명령어 내에 %를 이용해서 z-1값을 출력해봅시다. 

`!!IF&y1=0:M^당신은 %V1번째 방문자입니다. 당신은 세계의 마력이 %Z-1 알게 됍니다. ^; `

이제 y1=0인 조건일 때만 해당 메시지를 보게 됍니다.  

다음, 우리는 전투에서의 영웅의 능력을 변화하는 방법을 배웁니다. 

여기에는 다음처럼 코멘트를 남기면 좋겠지요 
`** 전투 시작시 작동하는 루틴이다. `

전투가 시작할때를 확인할 필요가 있습니다. 이제 새로운 트리거를 보도록 하죠.
`!?BA0;`
새로운 트리거는  앞쪽 코드를 중단합니다.   BA0 명령은 전투의 시작을 알립니다. 영어o가 아닌 숫자 0입니다. 우리는 전투의 종료를 알리는 트리거도 필요합니다. 

여러분들이 다른 쓰레드를 읽으면 알겠지만 전투 스크립트는 사람대사람으로 온라인 멀티플레이시에 문제가 있습니다. 지금은 우리코드가 아무런 문제가 없지만, 이런 상하큐에 대해서 체크할 필요가 있습니다.  이런 상황일 때는 해당 코드가 작동하지 않도록 합니다. 

`!!BA:E?y1; [온라인에서의 전투니?] `
BA리시버의 E옵션은 어떤상황에서의 전투인지를 묻습니다. `?y1`은 해당 결과를 y1에 저장하라는 명령입니다.  y1은 순간적으로 쓰는 변수이므로 걱정하지 말고 그냥 쓰도록 합시다. 

ERM도움말에 따르면 y1값은 호스트가 아닌 AI의 턴일 때 이 전투가 AI와 사람의 전투에서  2값을 출력한다. 만약 둘다 사람이면 hot-seat에서는 1값을 가지고 다른 상황에서는 0값을 가진다. ?? 무슨 소리인가.

이제 우리는 마지막 상황에 대해서만 작동할 스크립트만 알면된다. 배운바에 따르면 첫번째 두번째 케이스의 경우 원래 코드가 잘 안전하게 작동함을 알 수 있다. 다음줄을 넣어보자. 
`!!FU1&y1=0:Pv1; [ 아니면 스크립트가 계속됌. ] `

새로운 리시버가 등장했다. FU리시버는 다른 스크립트를 호출한다. 지금 같은 경우는 FU1이라는 명령을 호출한다. 지금은 y1=0이라는 조건이 있을때 해당 스크립트가 작동한다. 그렇지 않으면 작동치 않는다. 옵션P는 따라는 값들은 함수의 파라미터 값으로 넘기겠다는 의미이다. 

비록 지금은 필요하지 않지만 v1이라는 값을 파라미터로 넘겼다. 함수내에서 넘겨진 v1값이 조작되더라도 저장된 값에는 영향을 미치지 않는다. (v1을 직접다루는걸 이야기 하는게 아님). 

처음 전투시에는 이것이 필요치 않으므로 함수에 대해서 바로 갈 수 있다. (?무슨소리)

우리는 새로운 코드영역으로 안내하는 함수트리거를 사용하기 시작해보자. 
```erm
** 전투시작전의 작동 
!?FU1; 
```
우리는 전투를 하는 어떤 영웅의 SP를 수정하기를 원하므로 누가 전투를 하는지 알 필요가 있다. 또 양쪽이 누가 공격자이고 방어자인지도 알 필요가 있다. 
```erm
!!BA:H0/?v5; [ 공격자 영웅의 번호. ] 
!!BA:H1/?v6; [ 방어자 영웅의 번호. ] 
```

H옵션은 영웅 번호를 묻는다. H0는 공격자에게로, H1은 수비자에게로 참조한다. 만약 수비자에게 영웅이 없다면, -2라는 값을 출력한다. 모든 영웅의 영웅 번호는 ERM도움말에 있다. v5,v6는 해당 영웅값들을 받기위해 선택된 변수이다.  v3,v4는 내가 다른 목적으로 사용했기에 그렇게 했다. 

이제 어떤 방식의 SP변화를 적용할지에 대해 알아야한다. 우리는 그 값을 y변수에 저장했다. 이 값들이 여전히 메모리에 있지 않다. 우리는 그값이 그대로 있을지 없을지 추측하기 어렵다. 그래서 우리는 받아온  v1카운터를 이용한다. 
`!!VRx1::10%3; [마법변화 타입] `

약간의 변화가 보인다. v1대신 x1을 사용했다. x변수는 x1부터 x15까지 FU리시버로부터 전달 받는다. 지금은 v1값을 전달 받았으므로 x1은 그 값을 받는다. x16의 경우는 특별한 변수로 당신이 16번째 변수로 전달할 수 있으나 특별한 목적으로 사용 된다. 그러므로 x16사용을 회피하자. 그리고 x변수는 정수만 받을 수 있으므로 z변수를 전달 받지 못한다.
::두개의 콜론에 놀라지 말라. 첫번째는 VR리시버로부터의 분리이고 두번째는 나누기 연산자이다. 이제 x1값은 앞에서의 y2의 값이 된다. 

거의 준비가 마무리 되었다. 이제 우리는  영웅의 스펠파워 값을 알아보는 방법을 필요로한다. 
```erm
!!HEv5:F?y5/?y6/?y3/?y7; [ 공격자의 스탯 ] 
!!HEv6&v6>=0:F?y5/?y6/?y4/?y7; [ 수비자의 스탯 ] 
```
HE리시버는 모든 영웅의 각종 갑을 수정하는데 쓴다.  첫줄은 공격자의 값을 두번째는 영웅이 있다면 수비영웅의 값을 방아온다. (요거 안하면 에러난다. )

F옵션은 영웅의 일차스킬을 받아온다. 그리고 4개의 slash로 구분된 값은 순서대ㄹ 공격력 방여력 마력 지력이다. y5,y6,y7은 중복되지만 이 후에 사용하지 않으므로 상관없다. 

각종 값을 잡아놓는건 따로 이야기 하는게 좋을 것이니, 까먹어도 그때 다시 배우면 될 듯하다. 

이제 우리는 원하는 변화값으로 초기화 할 필요가 있다. 이제 이 값을 어떻게 바꾸고 또, 이전값을 어떻게 저장할지에 대해 알 필요가 있다. 우리는 v3, v4를 를 y3,y4값에 따라 사용해보자. 

```erm
!!VRv3&x1=1:Sy3; [마력강화면 마력강화 ]
!!VRv3&x1=2:S1-y3; [마력약화면 마력약화 ]
!!VRv4&x1=1/v6>=0:Sy4;  [ 수비자도 동일.]
!!VRv4&x1=2/v6>=0:S1-y4; 
```
3,4번째 줄에서 새로운 것이 나온다. 이 slash는 논리and연산을 말한다. `&x1=2/v6>=0`은 `if x1 ==2 and v6>= 0`을 말한다.  

이제 우리는 변화를 주는법을 필요로 한다. 
```erm
!!HEv5&x1<>0:Fd0/d0/dv3/d0; [SP수정]
!!HEv6&x1<>0/v6>=0:Fd0/d0/dv4/d0;  [방어자도.]
```
여기서는 x1이 0이 아닐 때, magic power를 바꾸지 않음을 알고 있다.  다시 HE:F 명령을 사용했다. 여기서 d는 이전값에대한 가산연산을 바로 대입하도록 해준다. d0은 이전값을 그대로 두리라는 의미로 사용한다. 

이제 우리는 전투전 명령어에 대해 완성하였다. 
```erm
 
!#VRv1:S0;  [v1초기화]
!?LE0/0/0;  [북서 끝단 이벤트 트리거]
!!VRv1:+1;  [v1+=1]
!!VRy1:Sv1%10; [v1이 10의 배수이냐?]
!!IF&y1<>0:M^너 북서 끝쪽에 %V1번 방문 했다. ^;
!!VRy2:Sv1:10%3; [마법 바꿀 타입]
!!VRz-1&y2=0:S^원래대로 돌아옴을^; [ 30,60,90번째 ] 
!!VRz-1&y2=1:S^강회됌을^; [ 10,40,70번째 ] 
!!VRz-1&y2=2:S^약화됌을^; [ 20,50,80번째 ] 
!!IF&y1=0:M^당신은 %V1번째 방문자입니다. 당신은 세계의 마력이 %Z-1 알게 됍니다. ^; 

** 전투 시작시 작동하는 루틴이다. 

!?BA0;
!!BA:E?y1; [온라인에서의 전투니?] 
!!FU1&y1=0:Pv1; [ 아니면 스크립트가 계속됌. ] 

** 전투시작전의 작동 

!?FU1;
!!BA:H0/?v5; [ 공격자 영웅의 번호. ] 
!!BA:H1/?v6; [ 방어자 영웅의 번호. ] 
!!VRx1::10%3; [마법변화 타입] 
!!HEv5:F?y5/?y6/?y3/?y7; [ 공격자의 스탯 ] 
!!HEv6&v6>=0:F?y5/?y6/?y4/?y7; [ 수비자의 스탯 ] 
!!VRv3&x1=1:Sy3; [마력강화면 마력강화 ]
!!VRv3&x1=2:S1-y3; [마력약화면 마력약화 ]
!!VRv4&x1=1/v6>=0:Sy4;  [ 수비자도 동일.]
!!VRv4&x1=2/v6>=0:S1-y4; 
!!HEv5&x1<>0:Fd0/d0/dv3/d0; [SP수정]
!!HEv6&x1<>0/v6>=0:Fd0/d0/dv4/d0;  [방어자도.]
```

이제 전투 후의 원래대로 돌릴 필요가 있다. 먼저 전투 후 트리거를 소개한다. 
```
** 전투 후에  작동하는 루틴이다. 
!?BA1;
!!BA:E?y1; [온라인에서의 전투니?] 
!!FU2&y1=0:Pv1; [ 아니면 스크립트가 계속됌. ] 
```

비슷하지 않나? 사실 트리거만 바뀌고 함수번호만 바뀌었다. BA1트리거는 전투 종료를 말한다. 그리고 이제 스탯을 원래대로 돌리면 된다. 우리는 변화값을 알고 있으므로, 쉽게 할 수 있다. 

```erm
!?FU2;
!!VRx1::10%3; [마법변화 타입] 
!!VRv3:*-1; [변화값의 음의 값을 취함.]
!!VRv4:*-1; [수비자도 ]
!!HEv5&x1<>0:Fd0/d0/dv3/d0; [SP수정원래대로]
!!HEv6&x1<>0/v6>=0:Fd0/d0/dv4/d0;  [방어자도.]
```
똑같이 작동했다. 
우리는 영웅번호를 저장하였다. 전투 종료 후 영웅을 물리치면, 전장에 영웅이 없어지기에 미리 저장하고 작동할 필요가 있다. 

이제 우리의 스크립트는 완료가 되었다. 
